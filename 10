    ###Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
    ```
locks=# show log_lock_waits;
 log_lock_waits 
----------------
 off
(1 row)

locks=# ALTER SYSTEM SET log_lock_waits = on;
ALTER SYSTEM
locks=# SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

locks=# show log_lock_waits;
 log_lock_waits 
----------------
 on
(1 row)

locks=# show log_min_duration_statement;
 log_min_duration_statement 
----------------------------
 -1
(1 row)


locks=# ALTER SYSTEM SET log_min_duration_statement = 200;
ALTER SYSTEM
locks=# SELECT pg_reload_conf();
 pg_reload_conf 
----------------
 t
(1 row)

locks=# show log_min_duration_statement;
 log_min_duration_statement 
----------------------------
 200ms
(1 row)

locks=# 


-- Session #1
\c locks
-- Воспроизведем блокировку
BEGIN;
UPDATE accounts SET amount = amount - 100.00 WHERE acc_no = 1;

-- Session #2
sudo -u postgres psql
\c locks
BEGIN;
UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;
-- Вторая команда UPDATE ожидает блокировку. Подождем секунду и завершим первую транзакцию.

-- Session #1

COMMIT;

-- Session #2
-- Теперь и вторая транзакция может завершиться
COMMIT;



root@bda-6:/home/yc-user# tail -n 30 /var/log/postgresql/postgresql-15-main.log

2024-03-11 08:19:30.398 UTC [8256] postgres@locks LOG:  process 8256 still waiting for ShareLock on transaction 81225 after 1000.204 ms
2024-03-11 08:19:30.398 UTC [8256] postgres@locks DETAIL:  Process holding the lock: 8143. Wait queue: 8256.
2024-03-11 08:19:30.398 UTC [8256] postgres@locks CONTEXT:  while updating tuple (0,1) in relation "accounts"
2024-03-11 08:19:30.398 UTC [8256] postgres@locks STATEMENT:  UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;
2024-03-11 08:20:52.078 UTC [8256] postgres@locks LOG:  process 8256 acquired ShareLock on transaction 81225 after 82680.042 ms
2024-03-11 08:20:52.078 UTC [8256] postgres@locks CONTEXT:  while updating tuple (0,1) in relation "accounts"
2024-03-11 08:20:52.078 UTC [8256] postgres@locks STATEMENT:  UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;
2024-03-11 08:20:52.078 UTC [8256] postgres@locks LOG:  duration: 82680.958 ms  statement: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1; 
```


    

###Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.

locks=# BEGIN;
BEGIN
locks=*# SELECT txid_current(), pg_backend_pid();
 txid_current | pg_backend_pid 
--------------+----------------
        81243 |           9658
(1 row)

locks=*# UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;
UPDATE 1
locks=*# commit;
COMMIT
locks=# BEGIN;
BEGIN
locks=*# SELECT txid_current(), pg_backend_pid();                      
 txid_current | pg_backend_pid 
--------------+----------------
        81246 |           9658
(1 row)

locks=*# UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1;
UPDATE 1
locks=*# SELECT * FROM locks_v WHERE pid = 9658;
 pid  |   locktype    |  lockid  |       mode       | granted 
------+---------------+----------+------------------+---------
 9658 | relation      | accounts | RowExclusiveLock | t
 9658 | transactionid | 81246    | ExclusiveLock    | t
(2 rows)

--Для 2 сесии с запросом UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1; 
locks=*# SELECT * FROM locks_v WHERE pid = 9856;
 pid  |   locktype    |   lockid    |       mode       | granted 
------+---------------+-------------+------------------+---------
 9856 | relation      | accounts    | RowExclusiveLock | t
 9856 | tuple         | accounts:11 | ExclusiveLock    | t
 9856 | transactionid | 81246       | ShareLock        | f
 9856 | transactionid | 81247       | ExclusiveLock    | t
(4 rows)

--Для 3 сесии с запросом UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 1; 
locks=*# SELECT * FROM locks_v WHERE pid = 9912;
 pid  |   locktype    |   lockid    |       mode       | granted 
------+---------------+-------------+------------------+---------
 9912 | relation      | accounts    | RowExclusiveLock | t
 9912 | tuple         | accounts:11 | ExclusiveLock    | f
 9912 | transactionid | 81248       | ExclusiveLock    | t
(3 rows)

locks=*#  SELECT pid, wait_event_type, wait_event, pg_blocking_pids(pid) FROM pg_stat_activity WHERE backend_type = 'client backend' ORDER BY pid;
 pid  | wait_event_type |  wait_event   | pg_blocking_pids 
------+-----------------+---------------+------------------
 8143 | Client          | ClientRead    | {}
 8562 | Client          | ClientRead    | {}
 8730 | Client          | ClientRead    | {}
 9026 | Client          | ClientRead    | {}
 9084 | Client          | ClientRead    | {}
 9518 | Client          | ClientRead    | {}
 9658 |                 |               | {}
 9727 | Client          | ClientRead    | {}
 9734 | Client          | ClientRead    | {}
 9735 | Client          | ClientRead    | {}
 9856 | Lock            | transactionid | {9658}
 9912 | Lock            | tuple         | {9856}
(12 rows)


locks=*# SELECT * FROM accounts_v LIMIT 20;
  ctid  | xmax  | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock 
--------+-------+-----------+----------+----------+-------------+----------
 (0,1)  | 81225 |           |          |          |             | 
 (0,2)  |     0 |           |          |          |             | 
 (0,3)  |     0 |           |          |          |             | 
 (0,4)  | 81243 |           |          |          |             | 
 (0,5)  | 81226 | t         |          |          | t           | 
 (0,6)  |     0 |           |          |          |             | 
 (0,7)  |     0 |           |          |          |             | 
 (0,8)  |     0 |           |          |          |             | 
 (0,9)  | 81244 |           |          |          |             | 
 (0,10) | 81245 |           |          |          |             | 
 (0,11) | 81246 |           |          |          |             | 
 (0,12) |     0 |           |          |          |             | 
(12 rows)



#Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
locks=# BEGIN;
BEGIN
locks=*# SELECT txid_current(), pg_backend_pid();
 txid_current | pg_backend_pid 
--------------+----------------
        81253 |           9658
(1 row)

locks=*# 
locks=*# 
locks=*# 
locks=*# UPDATE accounts SET amount = amount - 100.00 WHERE acc_no = 1;
UPDATE 1
locks=*# UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 2;

2 Сессия
locks=# BEGIN;
BEGIN
locks=*# SELECT txid_current(), pg_backend_pid();
 txid_current | pg_backend_pid 
--------------+----------------
        81254 |          10332
(1 row)

locks=*# 
locks=*# 
locks=*# 
locks=*# UPDATE accounts SET amount = amount - 10.00 WHERE acc_no = 2;
UPDATE 1
locks=*# UPDATE accounts SET amount = amount + 10.00 WHERE acc_no = 3;

3 Сессия
locks=# BEGIN;
BEGIN
locks=*# SELECT txid_current(), pg_backend_pid();
 txid_current | pg_backend_pid 
--------------+----------------
        81255 |          10350
(1 row)

locks=*# 
locks=*# 
locks=*# UPDATE accounts SET amount = amount + 1000.00 WHERE acc_no = 3;
UPDATE 1
locks=*# UPDATE accounts SET amount = amount - 1000.00 WHERE acc_no = 1;
ERROR:  deadlock detected
DETAIL:  Process 10350 waits for ShareLock on transaction 81253; blocked by process 9658.
Process 9658 waits for ShareLock on transaction 81254; blocked by process 10332.
Process 10332 waits for ShareLock on transaction 81255; blocked by process 10350.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,18) in relation "accounts"

root@bda-6:/home/yc-user# tail -n 20 /var/log/postgresql/postgresql-15-main.log
2024-03-11 10:19:31.541 UTC [10350] postgres@locks LOG:  process 10350 detected deadlock while waiting for ShareLock on transaction 81253 after 1000.078 ms
2024-03-11 10:19:31.541 UTC [10350] postgres@locks DETAIL:  Process holding the lock: 9658. Wait queue: .
2024-03-11 10:19:31.541 UTC [10350] postgres@locks CONTEXT:  while updating tuple (0,18) in relation "accounts"
2024-03-11 10:19:31.541 UTC [10350] postgres@locks STATEMENT:  UPDATE accounts SET amount = amount - 1000.00 WHERE acc_no = 1;
2024-03-11 10:19:31.541 UTC [10350] postgres@locks ERROR:  deadlock detected
2024-03-11 10:19:31.541 UTC [10350] postgres@locks DETAIL:  Process 10350 waits for ShareLock on transaction 81253; blocked by process 9658.
        Process 9658 waits for ShareLock on transaction 81254; blocked by process 10332.
        Process 10332 waits for ShareLock on transaction 81255; blocked by process 10350.
        Process 10350: UPDATE accounts SET amount = amount - 1000.00 WHERE acc_no = 1;
        Process 9658: UPDATE accounts SET amount = amount + 100.00 WHERE acc_no = 2;
        Process 10332: UPDATE accounts SET amount = amount + 10.00 WHERE acc_no = 3;
2024-03-11 10:19:31.541 UTC [10350] postgres@locks HINT:  See server log for query details.
2024-03-11 10:19:31.541 UTC [10350] postgres@locks CONTEXT:  while updating tuple (0,18) in relation "accounts"
2024-03-11 10:19:31.541 UTC [10350] postgres@locks STATEMENT:  UPDATE accounts SET amount = amount - 1000.00 WHERE acc_no = 1;
2024-03-11 10:19:31.541 UTC [10332] postgres@locks LOG:  process 10332 acquired ShareLock on transaction 81255 after 17711.831 ms
2024-03-11 10:19:31.541 UTC [10332] postgres@locks CONTEXT:  while updating tuple (0,3) in relation "accounts"
2024-03-11 10:19:31.541 UTC [10332] postgres@locks STATEMENT:  UPDATE accounts SET amount = amount + 10.00 WHERE acc_no = 3;
2024-03-11 10:19:31.541 UTC [10332] postgres@locks LOG:  duration: 17712.068 ms  statement: UPDATE accounts SET amount = amount + 10.00 WHERE acc_no = 3;
2024-03-11 10:19:43.738 UTC [581] LOG:  checkpoint starting: time
2024-03-11 10:19:43.850 UTC [581] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.103 s, sync=0.003 s, total=0.113 s; sync files=2, longest=0.003 s, average=0.002 s; distance=1 kB, estimate=186 kB



Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
Да могут, когда едимоментно будет изменяться одна и таже строка.
